    - Know that the generated test will be in a different directory (`tests`) than the module (in directory `pdd`) it is calling and will need an absolute reference. The module file name will be same as the function name.
    - Created files should be in the `output` directory.
    - Data files (language_format.csv and llm_model.csv) already exist in the PDD_PATH/`data` directory. Do not write over them. It already contains data for popular languages and LLM models and can be used for tests.
    - The PDD_PATH environment variable is already set.

% PYTEST TEST ISOLATION AND ANTI-POLLUTION RULES:
% CRITICAL: Generated tests MUST be isolated and not pollute state for other tests. Follow these rules strictly:

% 1. ENVIRONMENT VARIABLES:
    - ALWAYS use monkeypatch.setenv() or monkeypatch.delenv() instead of os.environ["VAR"] = "value"
    - NEVER use direct os.environ manipulation - it persists beyond the test and pollutes other tests
    - BAD:  os.environ["API_KEY"] = "test_key"  # POLLUTION: persists after test ends
    - GOOD: monkeypatch.setenv("API_KEY", "test_key")  # Auto-cleaned by pytest

% 2. MOCKING EXTERNAL DEPENDENCIES:
    - Use context managers or monkeypatch for mocks - they auto-cleanup after the test
    - Prefer monkeypatch.setattr() over unittest.mock.patch() decorators at module level
    - BAD:  @patch('module.func') at module/class level  # Can leak if exception occurs
    - GOOD: monkeypatch.setattr('module.func', mock_func)  # Always cleaned up
    - GOOD: with patch('module.func') as mock:  # Context manager ensures cleanup

% 3. FIXTURE CLEANUP WITH YIELD:
    - Use yield-based fixtures with cleanup code after yield for any resources
    - Prefer function-scoped fixtures over module or session scope to ensure isolation
    - BAD:  @pytest.fixture(scope="module") without cleanup  # State leaks between tests
    - GOOD: @pytest.fixture with yield and cleanup after yield  # Always cleans up
    - Example of proper fixture:
        @pytest.fixture
        def temp_resource():
            resource = setup_resource()
            yield resource
            resource.cleanup()  # Always runs after test, even on failure

% 4. SYS.MODULES MANIPULATION:
    - AVOID manipulating sys.modules directly whenever possible
    - If unavoidable, ALWAYS save and restore in try/finally or fixture with yield
    - BAD:  sys.modules["module"] = mock_module  # Pollutes all subsequent tests
    - GOOD: Use a fixture that saves, mocks, and restores:
        @pytest.fixture
        def mock_module():
            saved = sys.modules.get("module")
            sys.modules["module"] = MagicMock()
            yield
            if saved is not None:
                sys.modules["module"] = saved
            elif "module" in sys.modules:
                del sys.modules["module"]

% 5. FILE SYSTEM OPERATIONS:
    - ALWAYS use the tmp_path fixture for creating temporary files and directories
    - NEVER create files in the working directory or fixed paths
    - BAD:  with open("test_output.txt", "w") as f: ...  # Leaves file behind
    - GOOD: def test_file(tmp_path): (tmp_path / "test_output.txt").write_text(...)

% 6. GLOBAL/MODULE STATE:
    - Never modify global variables or module-level state directly in tests
    - Use monkeypatch.setattr() for any module-level variables that need changing
    - Reset any singleton instances using fixtures with proper teardown

% SUMMARY OF GOOD PATTERNS:
    - Use tmp_path fixture for file operations
    - Use monkeypatch fixture for environment variables and attributes
    - Use pytest.raises() as context manager for exception testing
    - Prefer function-scoped fixtures over module or session scope
    - Use yield in fixtures to ensure cleanup runs even on test failure

% 7. MODULE-LEVEL SYS.MODULES FOR IMPORT-TIME DEPENDENCIES:
    - Sometimes you must mock modules BEFORE importing the code under test
      (e.g., when decorators or top-level imports need mocking)
    - ALWAYS save original values, apply mocks, load module, then RESTORE immediately
    - BAD:  sys.modules.update(mocks); exec_module(...)  # No cleanup - pollutes all tests!
    - GOOD: See PATTERN 7 in pytest_isolation_example.py for the full save/restore pattern

<isolation_example>
<include>context/pytest_isolation_example.py</include>
</isolation_example>

% 8. SYS.PATH ISOLATION - PRIORITIZE LOCAL CODE OVER SITE-PACKAGES (Python only):
    - CRITICAL: When a package is installed (pip install), tests may import from site-packages
      instead of local repository code, causing tests to validate OLD code not CURRENT changes
    - This breaks pdd fix, CI/CD, and development workflows (see issue #342)
    - ALWAYS include sys.path setup in NEW test files to prioritize local code
    - NEVER include when appending to existing files (they should already have it)
    - BAD:  from mypackage import module  # Imports from site-packages if installed
    - GOOD: sys.path setup first, then import  # Local code takes priority, falls back to site-packages

% WHEN TO INCLUDE (NEW files only):
    - Generating a new test file (existing_tests parameter is None or empty string)
    - Language is Python
    - Place AFTER standard library imports (sys, pathlib) but BEFORE code under test imports

% WHEN TO SKIP:
    - Appending to existing test file (existing_tests parameter has content)
    - Non-Python languages

% TEMPLATE for new Python test files:
        import sys
        from pathlib import Path

        # Ensure local repository code is tested, not installed site-packages version
        # This prevents tests from using stale code when package is installed (issue #342)
        _repo_root = Path(__file__).resolve().parent.parent  # Adjust depth as needed
        if str(_repo_root) not in sys.path:
            sys.path.insert(0, str(_repo_root))

        # Now project imports find local code first, fall back to site-packages if not found
        from mypackage import module

% CALCULATING REPOSITORY ROOT DEPTH:
    - Count directory levels from test file location to repository root
    - Common patterns:
        * tests/test_foo.py → parent.parent (2 levels: tests/ → repo/)
        * test/unit/test_foo.py → parent.parent.parent (3 levels: unit/ → test/ → repo/)
        * src/tests/test_foo.py → parent.parent.parent (3 levels: tests/ → src/ → repo/)
    - If test_file_path is provided, use it to determine depth
    - If source_file_path shows code in src/, tests likely in tests/ → parent.parent
    - Default to parent.parent when uncertain (most common: tests/ at repo root)

% WHY THIS WORKS:
    - sys.path.insert(0, ...) puts local repo at front of Python's import search path
    - Python searches in order: finds local code first, then falls back to site-packages
    - Non-breaking: still imports dependencies from site-packages if not in local repo
    - Self-contained: works regardless of PYTHONPATH, pytest.ini, or IDE settings
